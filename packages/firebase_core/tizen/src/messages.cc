// Autogenerated from Pigeon (v3.2.9), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

/* PigeonFirebaseOptions */

const std::string& PigeonFirebaseOptions::api_key() const { return api_key_; }
void PigeonFirebaseOptions::set_api_key(std::string_view value_arg) {
  api_key_ = value_arg;
}

const std::string& PigeonFirebaseOptions::app_id() const { return app_id_; }
void PigeonFirebaseOptions::set_app_id(std::string_view value_arg) {
  app_id_ = value_arg;
}

const std::string& PigeonFirebaseOptions::messaging_sender_id() const {
  return messaging_sender_id_;
}
void PigeonFirebaseOptions::set_messaging_sender_id(
    std::string_view value_arg) {
  messaging_sender_id_ = value_arg;
}

const std::string& PigeonFirebaseOptions::project_id() const {
  return project_id_;
}
void PigeonFirebaseOptions::set_project_id(std::string_view value_arg) {
  project_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::auth_domain() const {
  return auth_domain_ ? &(*auth_domain_) : nullptr;
}
void PigeonFirebaseOptions::set_auth_domain(const std::string_view* value_arg) {
  auth_domain_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_auth_domain(std::string_view value_arg) {
  auth_domain_ = value_arg;
}

const std::string* PigeonFirebaseOptions::database_u_r_l() const {
  return database_u_r_l_ ? &(*database_u_r_l_) : nullptr;
}
void PigeonFirebaseOptions::set_database_u_r_l(
    const std::string_view* value_arg) {
  database_u_r_l_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_database_u_r_l(std::string_view value_arg) {
  database_u_r_l_ = value_arg;
}

const std::string* PigeonFirebaseOptions::storage_bucket() const {
  return storage_bucket_ ? &(*storage_bucket_) : nullptr;
}
void PigeonFirebaseOptions::set_storage_bucket(
    const std::string_view* value_arg) {
  storage_bucket_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_storage_bucket(std::string_view value_arg) {
  storage_bucket_ = value_arg;
}

const std::string* PigeonFirebaseOptions::measurement_id() const {
  return measurement_id_ ? &(*measurement_id_) : nullptr;
}
void PigeonFirebaseOptions::set_measurement_id(
    const std::string_view* value_arg) {
  measurement_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_measurement_id(std::string_view value_arg) {
  measurement_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::tracking_id() const {
  return tracking_id_ ? &(*tracking_id_) : nullptr;
}
void PigeonFirebaseOptions::set_tracking_id(const std::string_view* value_arg) {
  tracking_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_tracking_id(std::string_view value_arg) {
  tracking_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::deep_link_u_r_l_scheme() const {
  return deep_link_u_r_l_scheme_ ? &(*deep_link_u_r_l_scheme_) : nullptr;
}
void PigeonFirebaseOptions::set_deep_link_u_r_l_scheme(
    const std::string_view* value_arg) {
  deep_link_u_r_l_scheme_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_deep_link_u_r_l_scheme(
    std::string_view value_arg) {
  deep_link_u_r_l_scheme_ = value_arg;
}

const std::string* PigeonFirebaseOptions::android_client_id() const {
  return android_client_id_ ? &(*android_client_id_) : nullptr;
}
void PigeonFirebaseOptions::set_android_client_id(
    const std::string_view* value_arg) {
  android_client_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_android_client_id(std::string_view value_arg) {
  android_client_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::ios_client_id() const {
  return ios_client_id_ ? &(*ios_client_id_) : nullptr;
}
void PigeonFirebaseOptions::set_ios_client_id(
    const std::string_view* value_arg) {
  ios_client_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_ios_client_id(std::string_view value_arg) {
  ios_client_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::ios_bundle_id() const {
  return ios_bundle_id_ ? &(*ios_bundle_id_) : nullptr;
}
void PigeonFirebaseOptions::set_ios_bundle_id(
    const std::string_view* value_arg) {
  ios_bundle_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_ios_bundle_id(std::string_view value_arg) {
  ios_bundle_id_ = value_arg;
}

const std::string* PigeonFirebaseOptions::app_group_id() const {
  return app_group_id_ ? &(*app_group_id_) : nullptr;
}
void PigeonFirebaseOptions::set_app_group_id(
    const std::string_view* value_arg) {
  app_group_id_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void PigeonFirebaseOptions::set_app_group_id(std::string_view value_arg) {
  app_group_id_ = value_arg;
}

flutter::EncodableMap PigeonFirebaseOptions::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("apiKey"), flutter::EncodableValue(api_key_)},
      {flutter::EncodableValue("appId"), flutter::EncodableValue(app_id_)},
      {flutter::EncodableValue("messagingSenderId"),
       flutter::EncodableValue(messaging_sender_id_)},
      {flutter::EncodableValue("projectId"),
       flutter::EncodableValue(project_id_)},
      {flutter::EncodableValue("authDomain"),
       auth_domain_ ? flutter::EncodableValue(*auth_domain_)
                    : flutter::EncodableValue()},
      {flutter::EncodableValue("databaseURL"),
       database_u_r_l_ ? flutter::EncodableValue(*database_u_r_l_)
                       : flutter::EncodableValue()},
      {flutter::EncodableValue("storageBucket"),
       storage_bucket_ ? flutter::EncodableValue(*storage_bucket_)
                       : flutter::EncodableValue()},
      {flutter::EncodableValue("measurementId"),
       measurement_id_ ? flutter::EncodableValue(*measurement_id_)
                       : flutter::EncodableValue()},
      {flutter::EncodableValue("trackingId"),
       tracking_id_ ? flutter::EncodableValue(*tracking_id_)
                    : flutter::EncodableValue()},
      {flutter::EncodableValue("deepLinkURLScheme"),
       deep_link_u_r_l_scheme_
           ? flutter::EncodableValue(*deep_link_u_r_l_scheme_)
           : flutter::EncodableValue()},
      {flutter::EncodableValue("androidClientId"),
       android_client_id_ ? flutter::EncodableValue(*android_client_id_)
                          : flutter::EncodableValue()},
      {flutter::EncodableValue("iosClientId"),
       ios_client_id_ ? flutter::EncodableValue(*ios_client_id_)
                      : flutter::EncodableValue()},
      {flutter::EncodableValue("iosBundleId"),
       ios_bundle_id_ ? flutter::EncodableValue(*ios_bundle_id_)
                      : flutter::EncodableValue()},
      {flutter::EncodableValue("appGroupId"),
       app_group_id_ ? flutter::EncodableValue(*app_group_id_)
                     : flutter::EncodableValue()},
  };
}

PigeonFirebaseOptions::PigeonFirebaseOptions() {}

PigeonFirebaseOptions::PigeonFirebaseOptions(flutter::EncodableMap map) {
  auto& encodable_api_key = map.at(flutter::EncodableValue("apiKey"));
  if (const std::string* pointer_api_key =
          std::get_if<std::string>(&encodable_api_key)) {
    api_key_ = *pointer_api_key;
  }
  auto& encodable_app_id = map.at(flutter::EncodableValue("appId"));
  if (const std::string* pointer_app_id =
          std::get_if<std::string>(&encodable_app_id)) {
    app_id_ = *pointer_app_id;
  }
  auto& encodable_messaging_sender_id =
      map.at(flutter::EncodableValue("messagingSenderId"));
  if (const std::string* pointer_messaging_sender_id =
          std::get_if<std::string>(&encodable_messaging_sender_id)) {
    messaging_sender_id_ = *pointer_messaging_sender_id;
  }
  auto& encodable_project_id = map.at(flutter::EncodableValue("projectId"));
  if (const std::string* pointer_project_id =
          std::get_if<std::string>(&encodable_project_id)) {
    project_id_ = *pointer_project_id;
  }
  auto& encodable_auth_domain = map.at(flutter::EncodableValue("authDomain"));
  if (const std::string* pointer_auth_domain =
          std::get_if<std::string>(&encodable_auth_domain)) {
    auth_domain_ = *pointer_auth_domain;
  }
  auto& encodable_database_u_r_l =
      map.at(flutter::EncodableValue("databaseURL"));
  if (const std::string* pointer_database_u_r_l =
          std::get_if<std::string>(&encodable_database_u_r_l)) {
    database_u_r_l_ = *pointer_database_u_r_l;
  }
  auto& encodable_storage_bucket =
      map.at(flutter::EncodableValue("storageBucket"));
  if (const std::string* pointer_storage_bucket =
          std::get_if<std::string>(&encodable_storage_bucket)) {
    storage_bucket_ = *pointer_storage_bucket;
  }
  auto& encodable_measurement_id =
      map.at(flutter::EncodableValue("measurementId"));
  if (const std::string* pointer_measurement_id =
          std::get_if<std::string>(&encodable_measurement_id)) {
    measurement_id_ = *pointer_measurement_id;
  }
  auto& encodable_tracking_id = map.at(flutter::EncodableValue("trackingId"));
  if (const std::string* pointer_tracking_id =
          std::get_if<std::string>(&encodable_tracking_id)) {
    tracking_id_ = *pointer_tracking_id;
  }
  auto& encodable_deep_link_u_r_l_scheme =
      map.at(flutter::EncodableValue("deepLinkURLScheme"));
  if (const std::string* pointer_deep_link_u_r_l_scheme =
          std::get_if<std::string>(&encodable_deep_link_u_r_l_scheme)) {
    deep_link_u_r_l_scheme_ = *pointer_deep_link_u_r_l_scheme;
  }
  auto& encodable_android_client_id =
      map.at(flutter::EncodableValue("androidClientId"));
  if (const std::string* pointer_android_client_id =
          std::get_if<std::string>(&encodable_android_client_id)) {
    android_client_id_ = *pointer_android_client_id;
  }
  auto& encodable_ios_client_id =
      map.at(flutter::EncodableValue("iosClientId"));
  if (const std::string* pointer_ios_client_id =
          std::get_if<std::string>(&encodable_ios_client_id)) {
    ios_client_id_ = *pointer_ios_client_id;
  }
  auto& encodable_ios_bundle_id =
      map.at(flutter::EncodableValue("iosBundleId"));
  if (const std::string* pointer_ios_bundle_id =
          std::get_if<std::string>(&encodable_ios_bundle_id)) {
    ios_bundle_id_ = *pointer_ios_bundle_id;
  }
  auto& encodable_app_group_id = map.at(flutter::EncodableValue("appGroupId"));
  if (const std::string* pointer_app_group_id =
          std::get_if<std::string>(&encodable_app_group_id)) {
    app_group_id_ = *pointer_app_group_id;
  }
}

/* PigeonInitializeResponse */

const std::string& PigeonInitializeResponse::name() const { return name_; }
void PigeonInitializeResponse::set_name(std::string_view value_arg) {
  name_ = value_arg;
}

const PigeonFirebaseOptions& PigeonInitializeResponse::options() const {
  return options_;
}
void PigeonInitializeResponse::set_options(
    const PigeonFirebaseOptions& value_arg) {
  options_ = value_arg;
}

const bool* PigeonInitializeResponse::is_automatic_data_collection_enabled()
    const {
  return is_automatic_data_collection_enabled_
             ? &(*is_automatic_data_collection_enabled_)
             : nullptr;
}
void PigeonInitializeResponse::set_is_automatic_data_collection_enabled(
    const bool* value_arg) {
  is_automatic_data_collection_enabled_ =
      value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}
void PigeonInitializeResponse::set_is_automatic_data_collection_enabled(
    bool value_arg) {
  is_automatic_data_collection_enabled_ = value_arg;
}

const flutter::EncodableMap& PigeonInitializeResponse::plugin_constants()
    const {
  return plugin_constants_;
}
void PigeonInitializeResponse::set_plugin_constants(
    const flutter::EncodableMap& value_arg) {
  plugin_constants_ = value_arg;
}

flutter::EncodableMap PigeonInitializeResponse::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("name"), flutter::EncodableValue(name_)},
      {flutter::EncodableValue("options"),
       flutter::EncodableValue(options_.ToEncodableMap())},
      {flutter::EncodableValue("isAutomaticDataCollectionEnabled"),
       is_automatic_data_collection_enabled_
           ? flutter::EncodableValue(*is_automatic_data_collection_enabled_)
           : flutter::EncodableValue()},
      {flutter::EncodableValue("pluginConstants"),
       flutter::EncodableValue(plugin_constants_)},
  };
}

PigeonInitializeResponse::PigeonInitializeResponse() {}

PigeonInitializeResponse::PigeonInitializeResponse(flutter::EncodableMap map) {
  auto& encodable_name = map.at(flutter::EncodableValue("name"));
  if (const std::string* pointer_name =
          std::get_if<std::string>(&encodable_name)) {
    name_ = *pointer_name;
  }
  auto& encodable_options = map.at(flutter::EncodableValue("options"));
  if (const flutter::EncodableMap* pointer_options =
          std::get_if<flutter::EncodableMap>(&encodable_options)) {
    options_ = PigeonFirebaseOptions(*pointer_options);
  }
  auto& encodable_is_automatic_data_collection_enabled =
      map.at(flutter::EncodableValue("isAutomaticDataCollectionEnabled"));
  if (const bool* pointer_is_automatic_data_collection_enabled =
          std::get_if<bool>(&encodable_is_automatic_data_collection_enabled)) {
    is_automatic_data_collection_enabled_ =
        *pointer_is_automatic_data_collection_enabled;
  }
  auto& encodable_plugin_constants =
      map.at(flutter::EncodableValue("pluginConstants"));
  if (const flutter::EncodableMap* pointer_plugin_constants =
          std::get_if<flutter::EncodableMap>(&encodable_plugin_constants)) {
    plugin_constants_ = *pointer_plugin_constants;
  }
}

FirebaseCoreHostApiCodecSerializer::FirebaseCoreHostApiCodecSerializer() {}
flutter::EncodableValue FirebaseCoreHostApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return flutter::CustomEncodableValue(PigeonFirebaseOptions(
          std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 129:
      return flutter::CustomEncodableValue(PigeonInitializeResponse(
          std::get<flutter::EncodableMap>(ReadValue(stream))));

    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void FirebaseCoreHostApiCodecSerializer::WriteValue(
    const flutter::EncodableValue& value,
    flutter::ByteStreamWriter* stream) const {
  if (const flutter::CustomEncodableValue* custom_value =
          std::get_if<flutter::CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(PigeonFirebaseOptions)) {
      stream->WriteByte(128);
      WriteValue(flutter::EncodableValue(
                     std::any_cast<PigeonFirebaseOptions>(*custom_value)
                         .ToEncodableMap()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PigeonInitializeResponse)) {
      stream->WriteByte(129);
      WriteValue(flutter::EncodableValue(
                     std::any_cast<PigeonInitializeResponse>(*custom_value)
                         .ToEncodableMap()),
                 stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/** The codec used by FirebaseCoreHostApi. */
const flutter::StandardMessageCodec& FirebaseCoreHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &FirebaseCoreHostApiCodecSerializer::GetInstance());
}

/** Sets up an instance of `FirebaseCoreHostApi` to handle messages through the
 * `binary_messenger`. */
void FirebaseCoreHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                                FirebaseCoreHostApi* api) {
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.FirebaseCoreHostApi.initializeApp",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              const auto& args = std::get<flutter::EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("app_name_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_initialize_app_request_arg = args.at(1);
              if (encodable_initialize_app_request_arg.IsNull()) {
                wrapped.emplace(
                    flutter::EncodableValue("error"),
                    WrapError("initialize_app_request_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& initialize_app_request_arg =
                  std::any_cast<const PigeonFirebaseOptions&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_initialize_app_request_arg));
              api->InitializeApp(
                  app_name_arg, initialize_app_request_arg,
                  [&wrapped,
                   &reply](ErrorOr<PigeonInitializeResponse>&& output) {
                    if (output.has_error()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.error()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::CustomEncodableValue(
                                          std::move(output).TakeValue()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.FirebaseCoreHostApi.initializeCore",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              api->InitializeCore(
                  [&wrapped, &reply](ErrorOr<flutter::EncodableList>&& output) {
                    if (output.has_error()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.error()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::EncodableValue(
                                          std::move(output).TakeValue()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.FirebaseCoreHostApi.optionsFromResource",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              api->OptionsFromResource(
                  [&wrapped, &reply](ErrorOr<PigeonFirebaseOptions>&& output) {
                    if (output.has_error()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.error()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::CustomEncodableValue(
                                          std::move(output).TakeValue()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

flutter::EncodableMap FirebaseCoreHostApi::WrapError(
    std::string_view error_message) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(std::string(error_message))},
       {flutter::EncodableValue("code"), flutter::EncodableValue("Error")},
       {flutter::EncodableValue("details"), flutter::EncodableValue()}});
}
flutter::EncodableMap FirebaseCoreHostApi::WrapError(
    const FlutterError& error) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(error.message())},
       {flutter::EncodableValue("code"), flutter::EncodableValue(error.code())},
       {flutter::EncodableValue("details"), error.details()}});
}

FirebaseAppHostApiCodecSerializer::FirebaseAppHostApiCodecSerializer() {}

/** The codec used by FirebaseAppHostApi. */
const flutter::StandardMessageCodec& FirebaseAppHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &FirebaseAppHostApiCodecSerializer::GetInstance());
}

/** Sets up an instance of `FirebaseAppHostApi` to handle messages through the
 * `binary_messenger`. */
void FirebaseAppHostApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                               FirebaseAppHostApi* api) {
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.FirebaseAppHostApi."
            "setAutomaticDataCollectionEnabled",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              const auto& args = std::get<flutter::EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("app_name_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_enabled_arg = args.at(1);
              if (encodable_enabled_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("enabled_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
              api->SetAutomaticDataCollectionEnabled(
                  app_name_arg, enabled_arg,
                  [&wrapped, &reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.value()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::EncodableValue());
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.FirebaseAppHostApi."
            "setAutomaticResourceManagementEnabled",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              const auto& args = std::get<flutter::EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("app_name_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              const auto& encodable_enabled_arg = args.at(1);
              if (encodable_enabled_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("enabled_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
              api->SetAutomaticResourceManagementEnabled(
                  app_name_arg, enabled_arg,
                  [&wrapped, &reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.value()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::EncodableValue());
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.FirebaseAppHostApi.delete",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              const auto& args = std::get<flutter::EncodableList>(message);
              const auto& encodable_app_name_arg = args.at(0);
              if (encodable_app_name_arg.IsNull()) {
                wrapped.emplace(flutter::EncodableValue("error"),
                                WrapError("app_name_arg unexpectedly null."));
                reply(flutter::EncodableValue(std::move(wrapped)));
                return;
              }
              const auto& app_name_arg =
                  std::get<std::string>(encodable_app_name_arg);
              api->Delete(
                  app_name_arg,
                  [&wrapped, &reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      wrapped.emplace(flutter::EncodableValue("error"),
                                      WrapError(output.value()));
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    } else {
                      wrapped.emplace(flutter::EncodableValue("result"),
                                      flutter::EncodableValue());
                      reply(flutter::EncodableValue(std::move(wrapped)));
                    }
                  });
            } catch (const std::exception& exception) {
              wrapped.emplace(flutter::EncodableValue("error"),
                              WrapError(exception.what()));
              reply(flutter::EncodableValue(std::move(wrapped)));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

flutter::EncodableMap FirebaseAppHostApi::WrapError(
    std::string_view error_message) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(std::string(error_message))},
       {flutter::EncodableValue("code"), flutter::EncodableValue("Error")},
       {flutter::EncodableValue("details"), flutter::EncodableValue()}});
}
flutter::EncodableMap FirebaseAppHostApi::WrapError(const FlutterError& error) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(error.message())},
       {flutter::EncodableValue("code"), flutter::EncodableValue(error.code())},
       {flutter::EncodableValue("details"), error.details()}});
}
